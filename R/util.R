#' Argument matching with defaults
#'
#' \code{match_call_defaults} operates similar to \code{\link{match.call}}, but
#' considers also unset arguments for which defaults exist.
#'
#' @param call an unevaluated call to a function, as generated by
#'  \code{\link{call}}
#' @param .formals the formal argument definition of \code{call}
#' @return \code{match_call_defaults} returns a \code{call} corresponding to
#' the \code{call} argument, whose missing values have been filled in by the
#' defaults provided by \code{.formals}; the arguments are unevaluated.
#' @details
#' Both \code{call} and \code{.formals} have defaults which refer to the
#' function from which \code{match_call_defaults} was invoked. Thus, in normal
#' usage no arguments are specified.
#'
#' The function is useful to forward a call to a different function, when most
#' arguments remain unchanged. See examples.
#'
#' @examples
#' paste_csv = function (..., sep = ',', collapse = NULL) {
#'     call = base$match_call_defaults()
#'     call[[1]] = quote(paste)
#'     eval.parent(call)
#' }
#'
#' paste_csv('a', 'test') # => "a,test"
#' paste_csv('a', 'test', sep = ';') # => "a;test"
match_call_defaults = function (call = match.call(sys.function(sys.parent()),
                                                  sys.call(sys.parent())),
                                .formals = formals(sys.function(sys.parent()))) {
    .formals = .formals[names(.formals) != '...']
    missing = is.na(match(names(.formals), names(call)))
    missing_names = names(.formals)[missing]
    missing_values = .formals[missing]
    call[missing_names] = missing_values
    call
}

messageU <- function(..., underline='=', overline='=') {
    x <- paste0(..., collapse='')
    if (!is.null(overline)) {
        message(rep(overline, nchar(x)))
    }
    message(x)
    if (!is.null(underline)) {
        message(rep(underline, nchar(x)))
    }
}

startTimedMessage <- function(...) {
    x <- paste0(..., collapse='')
    message(x, appendLF=FALSE)
    ptm <- proc.time()
    return(ptm)
}

stopTimedMessage <- function(ptm) {
    time <- proc.time() - ptm
    message(" ", round(time[3],2), "s")
}

args2fname <- function(base, ..., ext='.rds') {
    fmt <- function(key, value) {
        if (is.character(value))
            paste(key, value, sep="_")
        else
            gsub("\\+0", "", sprintf("%s_%.2g", key, value))
    }
    args <- list(...)
    if (length(args) > 0) {
        fmtd <- paste(mapply(fmt, names(args), args), collapse="_")
        sprintf("%s_%s%s", base, fmtd, ext)
    } else
        sprintf("%s%s", base, ext)
}

makedir <- function(...) {
    path <- file.path(...)
    if (!file.exists(path))
        dir.create(path)
    invisible(path)
}
